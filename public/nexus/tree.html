<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEXUS - Tree Graph</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #0a0a0a;
            color: white;
            overflow: hidden;
        }

        canvas {
            display: block;
        }

        .controls {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 15px;
            border: 2px solid rgba(102, 126, 234, 0.3);
            z-index: 100;
        }

        .controls h1 {
            font-size: 1.8em;
            margin-bottom: 10px;
            background: linear-gradient(90deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .controls p {
            font-size: 0.9em;
            opacity: 0.7;
            margin-bottom: 15px;
        }

        .nav-links {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .nav-links a {
            color: white;
            text-decoration: none;
            padding: 8px 15px;
            background: rgba(102, 126, 234, 0.2);
            border: 1px solid #667eea;
            border-radius: 20px;
            font-size: 0.85em;
            transition: all 0.3s;
        }

        .nav-links a:hover {
            background: #667eea;
            transform: scale(1.05);
        }

        .stats {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid rgba(102, 126, 234, 0.3);
            font-size: 0.85em;
            z-index: 100;
        }

        .stats div {
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div class="controls">
        <h1>TREE GRAPH</h1>
        <p>Watch growth • Click nodes to expand</p>
        <div class="nav-links">
            <a href="../index.html">← Hub</a>
            <a href="index.html">Force Graph</a>
            <a href="neural.html">Neural Net</a>
        </div>
    </div>

    <div class="stats">
        <div>Nodes: <span id="nodeCount">0</span></div>
        <div>Depth: <span id="depthCount">0</span></div>
        <div>Branches: <span id="branchCount">0</span></div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width = canvas.width = window.innerWidth;
        let height = canvas.height = window.innerHeight;

        window.addEventListener('resize', () => {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        });

        class TreeNode {
            constructor(x, y, depth, parent, angle) {
                this.x = x;
                this.y = y;
                this.targetX = x;
                this.targetY = y;
                this.depth = depth;
                this.parent = parent;
                this.children = [];
                this.radius = Math.max(5, 15 - depth * 2);
                this.hue = (depth * 30) % 360;
                this.pulsePhase = Math.random() * Math.PI * 2;
                this.angle = angle;
                this.expanded = false;
                this.growth = 0;
                this.maxGrowth = 1;
            }

            update() {
                this.pulsePhase += 0.02;
                this.growth += (this.maxGrowth - this.growth) * 0.05;

                // Smooth movement
                this.x += (this.targetX - this.x) * 0.1;
                this.y += (this.targetY - this.y) * 0.1;
            }

            expand() {
                if (this.expanded || this.depth >= 6) return;

                this.expanded = true;
                const numChildren = Math.floor(Math.random() * 3) + 2;
                const angleSpread = Math.PI / 3;
                const startAngle = this.angle - angleSpread / 2;

                for (let i = 0; i < numChildren; i++) {
                    const childAngle = startAngle + (angleSpread / (numChildren - 1 || 1)) * i;
                    const distance = 80 - this.depth * 10;
                    const childX = this.x + Math.cos(childAngle) * distance;
                    const childY = this.y + Math.sin(childAngle) * distance;

                    const child = new TreeNode(this.x, this.y, this.depth + 1, this, childAngle);
                    child.targetX = childX;
                    child.targetY = childY;
                    this.children.push(child);
                    allNodes.push(child);
                }
            }

            draw() {
                const pulse = Math.sin(this.pulsePhase) * 0.3 + 1;

                // Draw connections to children
                if (this.children.length > 0) {
                    for (let child of this.children) {
                        const gradient = ctx.createLinearGradient(
                            this.x, this.y,
                            child.x, child.y
                        );
                        gradient.addColorStop(0, `hsla(${this.hue}, 100%, 50%, ${0.6 * child.growth})`);
                        gradient.addColorStop(1, `hsla(${child.hue}, 100%, 50%, ${0.4 * child.growth})`);

                        ctx.strokeStyle = gradient;
                        ctx.lineWidth = Math.max(1, 4 - this.depth) * child.growth;
                        ctx.beginPath();
                        ctx.moveTo(this.x, this.y);
                        ctx.lineTo(child.x, child.y);
                        ctx.stroke();

                        // Flowing particles on branch
                        if (child.growth > 0.5) {
                            const particleProgress = (Date.now() % 2000) / 2000;
                            const px = this.x + (child.x - this.x) * particleProgress;
                            const py = this.y + (child.y - this.y) * particleProgress;

                            ctx.fillStyle = `hsla(${this.hue}, 100%, 70%, ${0.8 * child.growth})`;
                            ctx.beginPath();
                            ctx.arc(px, py, 3, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                }

                if (this.growth < 0.01) return;

                // Glow
                const glowGradient = ctx.createRadialGradient(
                    this.x, this.y, 0,
                    this.x, this.y, this.radius * 3
                );
                glowGradient.addColorStop(0, `hsla(${this.hue}, 100%, 50%, ${0.6 * this.growth})`);
                glowGradient.addColorStop(0.5, `hsla(${this.hue}, 100%, 50%, ${0.3 * this.growth})`);
                glowGradient.addColorStop(1, 'hsla(0, 0%, 0%, 0)');

                ctx.fillStyle = glowGradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius * 3, 0, Math.PI * 2);
                ctx.fill();

                // Node
                ctx.fillStyle = `hsl(${this.hue}, 100%, 50%)`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius * pulse * this.growth, 0, Math.PI * 2);
                ctx.fill();

                // Core
                ctx.fillStyle = `rgba(255, 255, 255, ${0.8 * this.growth})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius * 0.5 * pulse * this.growth, 0, Math.PI * 2);
                ctx.fill();

                // Ring for expandable nodes
                if (!this.expanded && this.depth < 6 && this.growth > 0.9) {
                    ctx.strokeStyle = `hsla(${this.hue}, 100%, 70%, ${0.5 + Math.sin(this.pulsePhase) * 0.3})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius * 1.8, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }

            contains(x, y) {
                const dx = x - this.x;
                const dy = y - this.y;
                return Math.sqrt(dx * dx + dy * dy) < this.radius * 2;
            }
        }

        const allNodes = [];

        // Create root node
        const root = new TreeNode(width / 2, height / 2, 0, null, -Math.PI / 2);
        allNodes.push(root);

        // Auto-expand root
        setTimeout(() => root.expand(), 500);

        // Auto-grow tree
        setInterval(() => {
            const unexpandedNodes = allNodes.filter(n => !n.expanded && n.depth < 6 && n.growth > 0.9);
            if (unexpandedNodes.length > 0 && allNodes.length < 150) {
                const randomNode = unexpandedNodes[Math.floor(Math.random() * unexpandedNodes.length)];
                randomNode.expand();
            }
        }, 2000);

        // Click to expand
        canvas.addEventListener('click', (e) => {
            const mouseX = e.clientX;
            const mouseY = e.clientY;

            for (let node of allNodes) {
                if (node.contains(mouseX, mouseY) && !node.expanded && node.depth < 6) {
                    node.expand();
                    break;
                }
            }
        });

        function updateStats() {
            document.getElementById('nodeCount').textContent = allNodes.length;

            let maxDepth = 0;
            let branches = 0;
            for (let node of allNodes) {
                maxDepth = Math.max(maxDepth, node.depth);
                if (node.children.length > 0) branches++;
            }

            document.getElementById('depthCount').textContent = maxDepth;
            document.getElementById('branchCount').textContent = branches;
        }

        let lastStatsUpdate = 0;

        function animate(timestamp) {
            // Clear canvas
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, width, height);

            // Update and draw all nodes
            for (let node of allNodes) {
                node.update();
            }

            // Draw in reverse order so root is on top
            for (let i = allNodes.length - 1; i >= 0; i--) {
                allNodes[i].draw();
            }

            // Update stats
            if (timestamp - lastStatsUpdate > 200) {
                updateStats();
                lastStatsUpdate = timestamp;
            }

            requestAnimationFrame(animate);
        }

        animate(0);
    </script>
</body>
</html>
