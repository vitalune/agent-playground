<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MORPHEUS - Sacred Geometry</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #141e30 0%, #243b55 100%);
            color: white;
            overflow-x: hidden;
        }

        header {
            padding: 20px;
            text-align: center;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
        }

        h1 {
            font-size: 3em;
            background: linear-gradient(90deg, #ffd89b, #19547b);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .nav {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .nav a {
            color: white;
            text-decoration: none;
            padding: 10px 20px;
            background: rgba(255, 216, 155, 0.2);
            border: 2px solid #ffd89b;
            border-radius: 25px;
            transition: all 0.3s;
        }

        .nav a:hover {
            background: #ffd89b;
            color: #141e30;
            transform: scale(1.05);
        }

        .container {
            max-width: 1200px;
            margin: 40px auto;
            padding: 20px;
        }

        .canvas-wrapper {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 600px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 20px;
            margin-bottom: 30px;
        }

        canvas {
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(255, 216, 155, 0.3);
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }

        button {
            padding: 12px 30px;
            font-size: 1em;
            background: linear-gradient(135deg, #ffd89b, #19547b);
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
        }

        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(255, 216, 155, 0.4);
        }

        button.active {
            background: linear-gradient(135deg, #19547b, #ffd89b);
            box-shadow: 0 5px 15px rgba(255, 216, 155, 0.6);
        }

        .info {
            text-align: center;
            opacity: 0.8;
        }
    </style>
</head>
<body>
    <header>
        <h1>SACRED GEOMETRY</h1>
        <p>Divine patterns and sacred transformations</p>
        <div class="nav">
            <a href="index.html">‚Üê Morpheus</a>
            <a href="../index.html">Hub</a>
            <a href="blobs.html">Blob Animations</a>
        </div>
    </header>

    <div class="container">
        <div class="canvas-wrapper">
            <canvas id="geometryCanvas"></canvas>
        </div>

        <div class="controls">
            <button onclick="setPattern('flowerOfLife')" id="btn-flower">Flower of Life</button>
            <button onclick="setPattern('metatron')" id="btn-metatron">Metatron's Cube</button>
            <button onclick="setPattern('sri')" id="btn-sri">Sri Yantra</button>
            <button onclick="setPattern('vesica')" id="btn-vesica">Vesica Piscis</button>
            <button onclick="setPattern('spiral')" id="btn-spiral">Golden Spiral</button>
        </div>

        <div class="info">
            <p>Ancient geometric patterns that morph and evolve</p>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('geometryCanvas');
        const ctx = canvas.getContext('2d');

        canvas.width = 800;
        canvas.height = 600;

        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;

        let currentPattern = 'flowerOfLife';
        let rotation = 0;
        let scale = 1;
        let pulsePhase = 0;

        function drawFlowerOfLife() {
            const radius = 50;
            const circles = [
                { x: 0, y: 0 },
                { x: radius, y: 0 },
                { x: -radius, y: 0 },
                { x: radius / 2, y: radius * Math.sqrt(3) / 2 },
                { x: -radius / 2, y: radius * Math.sqrt(3) / 2 },
                { x: radius / 2, y: -radius * Math.sqrt(3) / 2 },
                { x: -radius / 2, y: -radius * Math.sqrt(3) / 2 },
                { x: radius * 1.5, y: radius * Math.sqrt(3) / 2 },
                { x: -radius * 1.5, y: radius * Math.sqrt(3) / 2 },
                { x: radius * 1.5, y: -radius * Math.sqrt(3) / 2 },
                { x: -radius * 1.5, y: -radius * Math.sqrt(3) / 2 },
                { x: 0, y: radius * Math.sqrt(3) },
                { x: 0, y: -radius * Math.sqrt(3) }
            ];

            circles.forEach((c, i) => {
                ctx.save();
                ctx.globalAlpha = 0.6;
                ctx.strokeStyle = `hsl(${(rotation * 2 + i * 20) % 360}, 100%, 70%)`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(c.x, c.y, radius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            });
        }

        function drawMetatronsCube() {
            const points = [];
            const radius = 120;

            // Outer circle points (6)
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                points.push({
                    x: Math.cos(angle) * radius,
                    y: Math.sin(angle) * radius
                });
            }

            // Inner circle points (6)
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2 + Math.PI / 6;
                points.push({
                    x: Math.cos(angle) * radius * 0.577,
                    y: Math.sin(angle) * radius * 0.577
                });
            }

            // Center point
            points.push({ x: 0, y: 0 });

            // Draw connections
            ctx.strokeStyle = `hsl(${rotation % 360}, 100%, 70%)`;
            ctx.lineWidth = 2;

            for (let i = 0; i < points.length; i++) {
                for (let j = i + 1; j < points.length; j++) {
                    ctx.save();
                    ctx.globalAlpha = 0.3;
                    ctx.beginPath();
                    ctx.moveTo(points[i].x, points[i].y);
                    ctx.lineTo(points[j].x, points[j].y);
                    ctx.stroke();
                    ctx.restore();
                }
            }

            // Draw circles at points
            points.forEach((p, i) => {
                ctx.save();
                ctx.fillStyle = `hsl(${(rotation + i * 30) % 360}, 100%, 70%)`;
                ctx.shadowBlur = 15;
                ctx.shadowColor = `hsl(${(rotation + i * 30) % 360}, 100%, 60%)`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            });
        }

        function drawSriYantra() {
            const layers = 5;

            for (let layer = 0; layer < layers; layer++) {
                const size = 150 - layer * 20;
                const hue = (rotation + layer * 60) % 360;

                ctx.save();
                ctx.strokeStyle = `hsl(${hue}, 100%, 70%)`;
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.7;

                // Upward triangles
                for (let i = 0; i < 4; i++) {
                    const offset = (i * Math.PI) / 2;
                    ctx.beginPath();
                    ctx.moveTo(0, -size);
                    ctx.lineTo(size * Math.sin(offset + Math.PI / 3), size * Math.cos(offset + Math.PI / 3));
                    ctx.lineTo(size * Math.sin(offset - Math.PI / 3), size * Math.cos(offset - Math.PI / 3));
                    ctx.closePath();
                    ctx.stroke();
                }

                // Downward triangles
                ctx.rotate(Math.PI);
                for (let i = 0; i < 4; i++) {
                    const offset = (i * Math.PI) / 2;
                    ctx.beginPath();
                    ctx.moveTo(0, -size * 0.9);
                    ctx.lineTo(size * 0.9 * Math.sin(offset + Math.PI / 3), size * 0.9 * Math.cos(offset + Math.PI / 3));
                    ctx.lineTo(size * 0.9 * Math.sin(offset - Math.PI / 3), size * 0.9 * Math.cos(offset - Math.PI / 3));
                    ctx.closePath();
                    ctx.stroke();
                }

                ctx.restore();
            }

            // Center dot
            ctx.save();
            ctx.fillStyle = `hsl(${rotation % 360}, 100%, 80%)`;
            ctx.shadowBlur = 20;
            ctx.shadowColor = `hsl(${rotation % 360}, 100%, 60%)`;
            ctx.beginPath();
            ctx.arc(0, 0, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }

        function drawVesicaPiscis() {
            const radius = 100;
            const offset = radius * 0.5;

            // Left circle
            ctx.save();
            ctx.strokeStyle = `hsl(${rotation % 360}, 100%, 70%)`;
            ctx.lineWidth = 3;
            ctx.globalAlpha = 0.6;
            ctx.beginPath();
            ctx.arc(-offset, 0, radius, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();

            // Right circle
            ctx.save();
            ctx.strokeStyle = `hsl(${(rotation + 120) % 360}, 100%, 70%)`;
            ctx.lineWidth = 3;
            ctx.globalAlpha = 0.6;
            ctx.beginPath();
            ctx.arc(offset, 0, radius, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();

            // Fill vesica
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            ctx.fillStyle = `hsla(${rotation % 360}, 100%, 60%, 0.3)`;
            ctx.beginPath();
            ctx.arc(-offset, 0, radius, -Math.acos(offset / radius), Math.acos(offset / radius));
            ctx.arc(offset, 0, radius, Math.PI - Math.acos(offset / radius), Math.PI + Math.acos(offset / radius));
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }

        function drawGoldenSpiral() {
            let size = 2;
            const phi = 1.618033988749895;
            let angle = 0;

            ctx.strokeStyle = `hsl(${rotation % 360}, 100%, 70%)`;
            ctx.lineWidth = 3;
            ctx.beginPath();

            for (let i = 0; i < 100; i++) {
                const x = Math.cos(angle) * size;
                const y = Math.sin(angle) * size;

                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);

                angle += 0.1;
                size *= 1.03;

                // Change color along spiral
                const hue = (rotation + i * 2) % 360;
                ctx.strokeStyle = `hsl(${hue}, 100%, 70%)`;
            }

            ctx.stroke();

            // Draw squares
            size = 5;
            let x = 0, y = 0;

            for (let i = 0; i < 8; i++) {
                ctx.save();
                ctx.strokeStyle = `hsl(${(rotation + i * 40) % 360}, 100%, 70%)`;
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.5;
                ctx.strokeRect(x - size / 2, y - size / 2, size, size);
                ctx.restore();

                // Position for next square (Fibonacci sequence)
                const prevSize = size;
                size *= phi;

                if (i % 4 === 0) x += prevSize;
                else if (i % 4 === 1) y += prevSize;
                else if (i % 4 === 2) x -= prevSize;
                else y -= prevSize;
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Update animation
            rotation += 0.5;
            pulsePhase += 0.05;
            scale = 1 + Math.sin(pulsePhase) * 0.1;

            // Apply transformations
            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.rotate(rotation * 0.005);
            ctx.scale(scale, scale);

            // Draw current pattern
            switch(currentPattern) {
                case 'flowerOfLife':
                    drawFlowerOfLife();
                    break;
                case 'metatron':
                    drawMetatronsCube();
                    break;
                case 'sri':
                    drawSriYantra();
                    break;
                case 'vesica':
                    drawVesicaPiscis();
                    break;
                case 'spiral':
                    drawGoldenSpiral();
                    break;
            }

            ctx.restore();

            requestAnimationFrame(draw);
        }

        function setPattern(pattern) {
            currentPattern = pattern;

            // Update button states
            document.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
            document.getElementById('btn-' + pattern.replace(/([A-Z])/g, '-$1').toLowerCase()).classList.add('active');
        }

        // Initialize
        document.getElementById('btn-flower').classList.add('active');
        draw();
    </script>
</body>
</html>
